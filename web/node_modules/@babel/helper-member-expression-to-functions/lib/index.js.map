<<<<<<< Updated upstream
{"version":3,"file":"index.js","sources":["../src/util.js","../src/index.js"],"sourcesContent":["/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return t.assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(path, base) {\n  const { node } = path;\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const { object } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee\n        .get(\"object\")\n        .replaceWith(t.assignmentExpression(\"=\", context, object));\n\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [\n        context,\n        ...node.arguments,\n      ]);\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(member) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent, parentPath }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (parentPath.isOptionalCallExpression()) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      });\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          t.callExpression(t.arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression()\n        ? \"object\"\n        : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n      for (let current = member; current !== endPath; ) {\n        const { parentPath } = current;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n      if (\n        t.isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      if (willEndPathCastToBoolean) {\n        const nonNullishCheck = t.logicalExpression(\n          \"&&\",\n          t.binaryExpression(\n            \"!==\",\n            baseNeedsMemoised\n              ? t.assignmentExpression(\n                  \"=\",\n                  t.cloneNode(baseRef),\n                  t.cloneNode(startingNode),\n                )\n              : t.cloneNode(baseRef),\n            t.nullLiteral(),\n          ),\n          t.binaryExpression(\n            \"!==\",\n            t.cloneNode(baseRef),\n            scope.buildUndefinedNode(),\n          ),\n        );\n        replacementPath.replaceWith(\n          t.logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        // todo: respect assumptions.noDocumentAll when assumptions are implemented\n        const nullishCheck = t.logicalExpression(\n          \"||\",\n          t.binaryExpression(\n            \"===\",\n            baseNeedsMemoised\n              ? t.assignmentExpression(\n                  \"=\",\n                  t.cloneNode(baseRef),\n                  t.cloneNode(startingNode),\n                )\n              : t.cloneNode(baseRef),\n            t.nullLiteral(),\n          ),\n          t.binaryExpression(\n            \"===\",\n            t.cloneNode(baseRef),\n            scope.buildUndefinedNode(),\n          ),\n        );\n        replacementPath.replaceWith(\n          t.conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? t.booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(\n          t.optionalCallExpression(\n            t.optionalMemberExpression(\n              endParent.callee,\n              t.identifier(\"call\"),\n              false,\n              true,\n            ),\n            [t.cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (_ref = (+_get(MEMBER))) + 1), _ref\n    // ++MEMBER   ->   _set(MEMBER, (+_get(MEMBER)) + 1)\n    if (parentPath.isUpdateExpression({ argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const value = t.binaryExpression(\n        operator[0],\n        t.unaryExpression(\"+\", this.get(member)),\n        t.numericLiteral(1),\n      );\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const { scope } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref });\n\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n\n        parentPath.replaceWith(\n          t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]),\n        );\n      }\n      return;\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parent;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            t.logicalExpression(\n              operatorTrunc,\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              t.binaryExpression(operatorTrunc, this.get(member), value),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          t.callExpression(t.arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    // MEMBER   ->   _get(MEMBER)\n    member.replaceWith(this.get(member));\n  },\n};\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"],"names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","AssignmentMemoiser","constructor","_map","WeakMap","has","key","get","record","value","count","t","set","toNonOptional","base","isOptionalMemberExpression","property","computed","isOptionalCallExpression","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","arguments","isInDetachedTree","isProgram","container","listKey","parentNode","handle","memoise","member","parent","endPath","find","isPattern","willEndPathCastToBoolean","rootParentPath","isUpdateExpression","argument","isAssignmentExpression","left","buildCodeFrameError","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","regular","current","endParentPath","replacementPath","nonNullishCheck","buildUndefinedNode","nullishCheck","endParent","simpleSet","prefix","ref","generateUidIdentifierBasedOnNode","push","id","operatorTrunc","slice","includes","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","memberExpressionToFunctions","visitor","state","traverse","memoiser"],"mappings":"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"}
=======
{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.LVal }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return t.assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.LVal, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (t.isOptionalMemberExpression(node)) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const { object } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee\n        .get(\"object\")\n        .replaceWith(t.assignmentExpression(\"=\", context as t.LVal, object));\n\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return t.callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (t.isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (t.isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          t.callExpression(t.arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression()\n        ? \"object\"\n        : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        t.isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? t.assignmentExpression(\n            \"=\",\n            t.cloneNode(baseRef),\n            t.cloneNode(startingNode),\n          )\n        : t.cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = t.binaryExpression(\n            \"!=\",\n            baseMemoised,\n            t.nullLiteral(),\n          );\n        } else {\n          nonNullishCheck = t.logicalExpression(\n            \"&&\",\n            t.binaryExpression(\"!==\", baseMemoised, t.nullLiteral()),\n            t.binaryExpression(\n              \"!==\",\n              t.cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          t.logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = t.binaryExpression(\n            \"==\",\n            baseMemoised,\n            t.nullLiteral(),\n          );\n        } else {\n          nullishCheck = t.logicalExpression(\n            \"||\",\n            t.binaryExpression(\"===\", baseMemoised, t.nullLiteral()),\n            t.binaryExpression(\n              \"===\",\n              t.cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          t.conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? t.booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          t.optionalCallExpression(\n            t.optionalMemberExpression(\n              endParent.callee,\n              t.identifier(\"call\"),\n              false,\n              true,\n            ),\n            [t.cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (_ref = (+_get(MEMBER))) + 1), _ref\n    // ++MEMBER   ->   _set(MEMBER, (+_get(MEMBER)) + 1)\n    if (t.isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const value = t.binaryExpression(\n        operator[0] as \"+\" | \"-\",\n        t.unaryExpression(\"+\", this.get(member)),\n        t.numericLiteral(1),\n      );\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const { scope } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref });\n\n        value.left = t.assignmentExpression(\n          \"=\",\n          t.cloneNode(ref),\n          // @ts-expect-error todo(flow->ts) value.left is possibly PrivateName, which is not usable here\n          value.left,\n        );\n\n        parentPath.replaceWith(\n          t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]),\n        );\n      }\n      return;\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            t.logicalExpression(\n              operatorTrunc as t.LogicalExpression[\"operator\"],\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              t.binaryExpression(\n                operatorTrunc as t.BinaryExpression[\"operator\"],\n                this.get(member),\n                value,\n              ),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          t.callExpression(t.arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"],"names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","AssignmentMemoiser","constructor","_map","WeakMap","has","key","get","record","value","count","t","assignmentExpression","set","toNonOptional","base","isOptionalMemberExpression","memberExpression","property","computed","isOptionalCallExpression","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","callExpression","identifier","arguments","isInDetachedTree","isProgram","container","listKey","parentNode","handle","memoise","member","noDocumentAll","parent","endPath","find","isPattern","arrowFunctionExpression","willEndPathCastToBoolean","rootParentPath","isUpdateExpression","argument","isAssignmentExpression","left","buildCodeFrameError","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","regular","current","endParentPath","isMemberExpression","replacementPath","baseMemoised","cloneNode","nonNullishCheck","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","nullishCheck","conditionalExpression","booleanLiteral","endParent","optionalCallExpression","optionalMemberExpression","simpleSet","prefix","unaryExpression","numericLiteral","ref","generateUidIdentifierBasedOnNode","push","id","sequenceExpression","operatorTrunc","slice","LOGICAL_OPERATORS","includes","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","isTaggedTemplateExpression","memberExpressionToFunctions","visitor","state","traverse","memoiser"],"mappings":"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"}
>>>>>>> Stashed changes
