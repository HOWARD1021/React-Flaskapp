/**
<<<<<<< Updated upstream
 * @fileoverview Enforce a new line after jsx elements and expressions.
 * @author Johnny Zabala
=======
 * @fileoverview Require or prevent a new line after jsx elements and expressions.
 * @author Johnny Zabala
 * @author Joseph Stiles
>>>>>>> Stashed changes
 */

'use strict';

const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = {
  meta: {
    docs: {
<<<<<<< Updated upstream
      description: 'Enforce a new line after jsx elements and expressions',
=======
      description: 'Require or prevent a new line after jsx elements and expressions.',
>>>>>>> Stashed changes
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-newline')
    },
<<<<<<< Updated upstream
    fixable: 'code'
=======
    fixable: 'code',

    messages: {
      require: 'JSX element should start in a new line',
      prevent: 'JSX element should not start in a new line'
    },
    schema: [
      {
        type: 'object',
        properties: {
          prevent: {
            default: false,
            type: 'boolean'
          }
        },
        additionalProperties: false
      }
    ]
>>>>>>> Stashed changes
  },
  create(context) {
    const jsxElementParents = new Set();
    const sourceCode = context.getSourceCode();
    return {
      'Program:exit'() {
        jsxElementParents.forEach((parent) => {
          parent.children.forEach((element, index, elements) => {
            if (element.type === 'JSXElement' || element.type === 'JSXExpressionContainer') {
              const firstAdjacentSibling = elements[index + 1];
              const secondAdjacentSibling = elements[index + 2];
<<<<<<< Updated upstream
              if (
                firstAdjacentSibling
                && secondAdjacentSibling
                && (firstAdjacentSibling.type === 'Literal' || firstAdjacentSibling.type === 'JSXText')
                // Check adjacent sibling has the proper amount of newlines
                && !/\n\s*\n/.test(firstAdjacentSibling.value)
              ) {
                context.report({
                  node: secondAdjacentSibling,
                  message: 'JSX element should start in a new line',
                  fix(fixer) {
                    return fixer.replaceText(
                      firstAdjacentSibling,
                      // double the last newline.
                      sourceCode.getText(firstAdjacentSibling)
                        .replace(/(\n)(?!.*\1)/g, '\n\n')
                    );
                  }
                });
              }
=======

              const hasSibling = firstAdjacentSibling
              && secondAdjacentSibling
              && (firstAdjacentSibling.type === 'Literal' || firstAdjacentSibling.type === 'JSXText');

              if (!hasSibling) return;

              // Check adjacent sibling has the proper amount of newlines
              const isWithoutNewLine = !/\n\s*\n/.test(firstAdjacentSibling.value);

              const prevent = !!(context.options[0] || {}).prevent;

              if (isWithoutNewLine === prevent) return;

              const messageId = prevent
                ? 'prevent'
                : 'require';

              const regex = prevent
                ? /(\n\n)(?!.*\1)/g
                : /(\n)(?!.*\1)/g;

              const replacement = prevent
                ? '\n'
                : '\n\n';

              context.report({
                node: secondAdjacentSibling,
                messageId,
                fix(fixer) {
                  return fixer.replaceText(
                    firstAdjacentSibling,
                    // double or remove the last newline
                    sourceCode.getText(firstAdjacentSibling)
                      .replace(regex, replacement)
                  );
                }
              });
>>>>>>> Stashed changes
            }
          });
        });
      },
      ':matches(JSXElement, JSXFragment) > :matches(JSXElement, JSXExpressionContainer)': (node) => {
        jsxElementParents.add(node.parent);
      }
    };
  }
};
